In this lecture, let's try to understand one more feature which got introduced in Java seven to make their life easy and the feature is easier exception handling. While we are using reflections inside of Java to just give a brief background about reflections, reflections in Java will allow you to load the classes dynamically at runtime, especially frameworks like Spring Hibernate. They use a lot of reflections under the line. If we can think of AOB concept, which is aspect oriented programming, where we provide point guards and advisors using spring framework that relies more on reflections concepts. So reflections will help you to lower classes at runtime. And you can also execute methods by loading a class at runtime, by invoking the method, whatever you want. But the point here that we are trying to speak is not about the reflections. There is a problem when we try to deal with reflections in terms of exception, handling as a developer, if I trying to load and class during runtime by using class that Farnam as I was showing in the slide, and once I load the class I'm trying to invoke a method inside it. There is no problem in this score. We are not complaining about this. The problem is when our developer is trying to do reflections related court, he is forced to catch multiple exceptions that may get thrown from the reflections concept itself. One is legal access exception. Like if you try to load a class at runtime, there might be scenarios you are not allowed due to security reasons. In such scenarios, you'll get a legal access exception and the same for invocation target exception. No such exception and class. Not one exception. Since your compiler is not compiling all this at compile time and it's trying to load and execute at runtime, that is very good chances that you may get no such metal exception and class, not for an exception. And it's very annoying, right? For me as a developer, I have to catch all these exceptions inside my cache block, though I'm mentioning here it has before Java seven, but I have used here inside the cache block, one of the Java seven feature, which is cache block with multiple exceptions inside it. I just put it for our easier replantation purpose. But you can think before Java seven, the developer will ended up writing for Catch Block with a single try block just because Reflections Concept is drawing all these kind of exceptions. Otherwise, he may have to have a single catch block which catches a generic exception type of class type exception. And that may not be feasible for all the time to the developers. Due to that reason, developers are always forced to catch multiple exceptions whenever they are dealing with reflections, since it's very annoying and tedious job for the developers, there is a room, there is a chance for improvement to club all these exceptions to make developer life easy. From those discussions, a new super class exception is introduced with the name reflective operation exception. So instead of catching all the four exceptions that we discussed previously, Assadullah. But if I catch Reflektor operation exception alone, that is good enough and compiler will not draw any comparison errors while it is trying to do check the exceptions validation. And this is made possible by creating a super class, as we discussed, reflect operation exception. As you can see, all these four different exceptions that we used to catch before Java seven day extending the superclass due to that reason. If I catch the superclass alone, it is enough for me as a developer and the compiler can handle all the sub exceptions where all of them extending a super class called Reflektor operation exception. I know this is more of a theory that has nothing to do with coding except. But let me show you a simple program about this feature. For that, I am going to the Eclipse ID. As you can see right now, we are on to a class called Exception Handling for reflective methods. As you can see, before Java seven, I ended up catching all the four exceptions. And if you use all the style of catching, which is before Java seven, you will end up having four catch blocks. But just for our representation purposes, I just use one of the Java feature. But with Java seven, you can see you don't have to catch all these four exceptions. You just have to catch the super exception, which is reflecting the operation exception. And the reason, because if you go and see any of this exception, you can find that extending reflect the operation exception. With this, I'm assuming you are very clear about this feature. Just make sure whenever you're trying to deal with reflections inside your code from Java seven or about Java seven versions, please make sure that you are leveraging reflect to operation exception instead of catching all the four different types of exceptions, usually a reflection. CorelDraw. Thank you. And see you in the next review by.