28. Behaviors can change over time
Hello, welcome back. Before we go any further with our case study, I'd like to now talk about what we are returning from the message handlers. So far we've been returning this from each of the 'un-messaged methods'. Although we did have one instance where we used behaviours dealt with timers as a wrapper for the return.this. And that became inside the behavior.timers. I think its now a good time to understand exactly what this return value is. The method that we are operating on, this 'Create Receive' method, by default has a return type of receive. And this is a genetic return type. This receive class is actually the definition of how a behaviour processes a message. In other words, when we finish the processing of any message, we actually need to return an object, Which is able to do the processing of the next message. So the concept is then that the way we process messages within an actor, can change over time. If we think back to the prime numbers example, when we first ask the employee worker to give us a prime number within the actors behaviour class, they create receive method runs. Which processes this message, and yet it goes off and does some work, it runs the code that calculates the large prime number. But the second time that we ask this actor to give us a prime number, it didn't need to all that work again, because it had already calculated a prime number and had stored that result is its state. So it could respond to the the sending actor straight away. When we implement this example in code, we achieve that functionality by using an "if statement". Within the message handler, we check to see if we had already stored the result as a value locally. If we had, we could just return it. We didn't need to do the work to recalculate it. Well that was fine, we know that works, but actually it turns out there's a better way to achieve this. What we can do is we can say that when a worker first starts up, it will use this existing "create receive" function. However, once its processed the start message once and it will therefore generated a prime number, then in future any message that we receive could be handled by a different version of this method. We could create a second "create receive" function, and say that in future, use the second version. We'll be able to switch between different message handlers over time, or actors can change their behaviour over time. And the way that we achieve this switching of message handlers is with this return key word. We can return the existing message handler or you could say a different message handler is going to be used. Now the "return this" that we've used so far is actually a shortcut for "return behaviors.same". By using "return behaviors.same", then what we saying is slightly clearer. We're saying that we want our actor to carry on having the exact same behaviour at the end of having processed this message. Actually "behaviors.same" and this aren't exactly the same thing, although the impact of them is the same. So you'll often see people using "return this" instead of "behaviors.same", they really do have the same effect so we'll think of them as meaning the same thing. From now on though, I think we'll always try and return "behaviors.same" in our message handlers just so that it's absolutely clear, that we're saying the same message handler the same behaviour as it's currently running within our actor will carry on running to process the next message when it arrives. Now we've already seen that we can change the behaviour by using "behaviors.withtimers" as part of this return, and that was a special case that returned a different set of behaviours while it sends out a message on a regular schedule. Although it keeps the underline message handler to handle those and any other messages. But what we can then return from this method is any other method that also looks like a message handler. That's any method that returns an object of this received type. So before I start changing the code, this is in the "BigPrimes" example. Lets just run this quickly once to remind ourselves of what it looks like. So each prime number is generated in turn and as you can see because we're asking for the prime numbers twice, we get the response to the second one almost instantly. So as the behaviour that we're seeing right now. If we re-architect them as to say we're going to have two different "create receive" methods or two different message handlers, this one initially and then a new version once we've already calculated the message. We'll see that we don't break anything but it's a more production standard way of codding this up. So the second message handler, I think I'm going to call it subsequent handler, will be a public method, the return type is "Receive Command". And I'll call this one subsequent handler. You can call it anything you'd like I think just because for the simple example we've got the initial message handler and then the subsequent one which will handle everything except for the initial message. So in here we're going to return our new receive builder. And I'll just put the build in at the end. And then when I'm going to copy this on any message into here, and then we'll start editing. Coz we've now got two versions, the initial one and the subsequent one. So in the initial one, what we know we won't have a prime number because this is only going to be processing the very first message. So we don't need to do this check. And let's just tidy this up a little bit. So when we get the first message we're calculating the new prime number, we're sending it back. And then rather then saying use the same message handler, we're going to instead of same, we want to return the subsequent handler. So in future, any message will be handled by this method instead. When we will be getting to this method, we know we've got a prime number, so I can remove the entirety of this if statement. We can just return the value. Now we can improve on this a little bit more but before we do that, lets check we've not broken anything and we'll just run this again. Great. So that looks to be working just like it did before. So lets go and improve this a little bit further. Well the first thing is that, it can be a little bit confusing when you have these multiple message handlers. So what I think is good practise generally, is to give every message handler a unique and meaningful name. So we've got this one called, "Subsequent handler", I think we should actually maybe rename this then to, " Handle Messages When We Already Have A Prime Number". And then the first one it'll be sensible if we'd call that something like, "Handle Messages When We Don't Yet Have A Prime Number". So lets rename this method to that. And then in this method we'll want to hand over to the, "Handle Messages When We Already Have A Prime Number method". But of course this method is no longer overriding anything, we need to always have a method called, "Create Receive". So lets put that in. But then the idea is, our very first "Create Receive" is just going to say our initial state is going to be to use this "Handle Messages When We Don't Yet Have A Prime Number". So just going to return that method. So the idea is then that the default "Create Receive" says this is the default message handler, this is the one we're going to use to start and actually that's going to subsequently move to this second message handler. Now I've used really long names here just to make the point, just to make it completely clear exactly what is happening. But before I run this, there's a further change we can make and again this is considered to be good practise. At the moment we're storing this "Big Integer" as a prime at the class level. And good practise with ACA says that whenever possible, don't have class level state. And one of the ways that we can get around nor have to store any state of class levels, is by using these multiple message handlers. We don't need to know the value of prime until we get down here into this method. So it could be declared within this method or even as a parameter to this method. So what we could do is remove the class level declaration all together. We can say that when we hand over to this method, we need to include include a big integer as a method parameter, which we can call "Prime". And now this method will compile and work, but then when we call it, we'll need to hand it over. So the way that we'll do that is we will store a big integer called, "Prime". In this method, We'll instantiate it here, that's fine and then we can use it. And then when we hand over to our second message handler, we can pass though the value. Now that might seem a little bit confusing at first. The idea is that we're creating an actor that doesn't have any real internal state. There are no private variables in this actor. When we create some state, we actually hand it to a method and the state leaves purely within the message handler method. And again, that's considered to be good practise. Okay, once we're getting this to compile, I either need to give the "Big Integer" an initial value, or I think what we could do is, we're only receiving one message, we don't really need to check the message type. So I'm just going to remove the if statement just to tidy this up a little bit. Whatever the message is that we receive, we're just going to be calculating a prime number. Because this was a very simple example, we didn't have multiple different message types. So in fact lets just move this down to tidy that up a little bit further. I think that looks okay. And I'll for consistency, remove the if statement from the second message handler, as well. So lets run this one more time, make sure we've not broken anything. And that does indeed still look to be working just fine. So to recap them what we've done is we've said there's an actor, one of outrworker actors in this example, has different ways of behaving. Initially it could behave in a certain way. It'll wait for a message and when it receives that message it will calculate a large prime number. But then for any future messages, its going to use some different code it's just going to return the prime number it already calculated. And if we think back to the idea of a manager and some employees, this makes sense. The first time the manager says to one of their employees, "please can you get me a number?" The employee will need to go and calculate one. But the second time the manager says to that employee, "can you calculate me a number?". The employee might well say, "well hold on a minute, I've done this already. I've given you a number, here it is again." So he does different work, he behaves in a different way. Just as individuals can act in a different way over time, so can actors. And its driven by changing state. You will eyeball respond to the same question differently based on what knowledge we have obtained. In ACA, actors can respond differently, based on their internal state.

29. Exercise 2 - Changing behaviors

30. Exercise 2 - walkthrough
